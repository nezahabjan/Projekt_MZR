#pozenemo na zacetku, da dobimo potrebno
library(igraph)
library(ggraph)
library(networkD3)
## v tej datoteki bom bele?ila glavne funkcije v projektu, ki se bodo potem uporabljale in klicale v shiny aplikaciji
# najprej nastavimo funkcije, ki bodo vrnile osnovne grafovske lastnosti poljubnega grafa
# A) kako narisemo graf?
# zacetna vzpostavitev poljubnega grafa preko incidencne matrike, ta vsebuje ?tevilo povezav od clena v vrstici do tistega v stolpcu
#v1 <- c(0,0,0,0,0)
#v2 <- c(0,0,0,1,0)
#v3 <- c(0,1,1,0,1)
#v4 <- c(0,1,0,1,0)
#v5 <- c(0,0,1,0,1)
#inc_matrika <- rbind(v1, v2, v3, v4, v5)
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
return(seznam)
}
# C) koliko povezav vsebuje?
graf <- narisi(inc_matrika, "yes", 4, 5, 2)
povezave <- function(graf) {
stevilo_povezav <- length(E(graf$network))
return(stevilo_povezav)
}
# D) ali ima nas graf cikle?
graf <- narisi("", "no", 4, 4, 3)
#cikli <- function(graf){
matrika <- graf$matrika
network <- graf$network
obiskani<- list()
seznam_stopenj <- stopnje(graf)
k <- 1
vozlisce <- names(network[1])[k]
while (seznam_stopenj[[vozlisce]] == 0){
obiskani[vozlisce] <- "DA"
k = k+1
vozlisce <- names(network[1])[k]
}
zacetni <- names(network[1])[k]
print(zacetni)
obiskani[zacetni] <- "DA"
# dobili smo prvega kandidata med vozlisci, kjer zacnemo preverjati ciklicnost
stars <- zacetni
otroci <- list()
cikel <- c()
while (length(obiskani)<length(names(network[1]))){
print(stars)
sosedje <- names(network[[stars]][[1]])
otroci[stars] <- sosedje
print(sosedje)
for (x in sosedje){
print(x)
if (obiskani[x]=="DA" && !(x %in% otroci[stars])){
print("imamo cikel")
print(cikel)
cikel <- c()
} else if (!(x %in% names(obiskani[]))){
print("Nadaljujmo")
cikel <- append(cikel, x)
print(cikel)
stars <- x
obiskani[x] <- "DA"
}
}
}
return(cikel)
}
# funkcija dela v redu ampak potrebno je izlo?iti iz rezultata cikle, ki se ponovijo le v drugem vrstnem redu!
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (length(Cikli)!=0){
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
} else {
print("Graf nima ciklov!")
}
}
# E) RE?EVANJE PROBLEMOV:
# 1) PROBLEM NAJDALJ?E IN NAJKRAJ?E POTI MED IZBRANIMA VOZLISCEMA
max_min_pot <- function(v1, v2, graf){
}
shiny::runApp()
runApp()
install.packages("shinydashboard")
library(igraph)
library(ggraph)
library(networkD3)
library(shiny)
library(shinydashboard)
library(shinyjs)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
library(igraph)
library(ggraph)
library(networkD3)
library(shiny)
library(shinydashboard)
library(shinyjs)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
setwd("C:/Users/Neža/Desktop/Neža šola/opb projekt/Projekt_MZR")
source('C:/Users/Neža/Desktop/Neža šola/opb projekt/Projekt_MZR/funkcije.R')
#pozenemo na zacetku, da dobimo potrebno
library(igraph)
library(ggraph)
library(networkD3)
library(shiny)
library(shinydashboard)
library(shinyjs)
source('C:/Users/Neža/Desktop/Neža šola/opb projekt/Projekt_MZR/funkcije.R')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
unlist(strsplit(input[[paste0("v",i)]])))
unlist(strsplit(input[[paste0("v",i)]]))
unlist(strsplit("0,1,0"))
unlist(strsplit("0,1,0", ,))
unlist(strsplit(0,1,0))
strsplit("0,1,2", ",")
unlist(strsplit("0,1,2", ","))
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == 2){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == 1){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" (2) ali "no" (1)
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "2"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "1"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" (2) ali "no" (1)
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "2"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "1"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
INPUT$1<- "0,1,0"
test <- list()
test$1 <- "0,1,0"
test$v1 <- "0,1,0"
test$v2 <- "0,1,1"
test$v3 <- "0,0,1"
as.matrix(lapply(1:3, function(i)
as.numeric(unlist(strsplit(input[[paste0("v",i)]], ",")))))
as.matrix(lapply(1:3, function(i)
as.numeric(unlist(strsplit(test[[paste0("v",i)]], ",")))))
as.matrix(lapply(1:3, function(i)
unlist(strsplit(test[[paste0("v",i)]], ","))))
unlist(strsplit(test[[paste0("v",1)]], ","))))
unlist(strsplit(test[[paste0("v",1)]], ",")))
unlist(strsplit(test[[paste0("v",1)]], ","))
a<-unlist(strsplit(test[[paste0("v",1)]], ",")))
a<-unlist(strsplit(test[[paste0("v",1)]], ","))
b<-unlist(strsplit(test[[paste0("v",2)]], ","))
c<-unlist(strsplit(test[[paste0("v",3)]], ","))
as.matrix(a,b,c)
b
c
matrix(a,b,c)
matrix(as.numeric(a,b,c))
matrix(as.numeric(a), as.numeric(b), as.numeric(c))
matrix(as.numeric(a), as.numeric(b), as.numeric(c), 3, 3)
matrix(as.numeric(a,b,c), 3, 3)
matrix(as.numeric(a,b,c), 3, 3, byrow =TRUE)
a
b
c
as.numeric(a,b,c)
as.numeric(a)
as.numeric(b)
matrix(c(as.numeric(a), as.numeric(b), as.numeric(c)), 3, 3)
matrix(c(as.numeric(a), as.numeric(b), as.numeric(c)), 3, 3, byrow=TRUE)
runApp('shiny')
matrix(c(lapply(1:3, function(i)
as.numeric(unlist(strsplit(test[[paste0("v",i)]], ","))))), 3, 3, byrow=TRUE)
matrix(c(as.numeric((lapply(1:3, function(i)
unlist(strsplit(test[[paste0("v",i)]], ","))))), 3, 3, byrow=TRUE)
)
matrix(c(as.numeric((apply(1:3, function(i)
unlist(strsplit(test[[paste0("v",i)]], ","))))), 3, 3, byrow=TRUE)
)
matrix(c(as.numeric((sapply(1:3, function(i)
unlist(strsplit(test[[paste0("v",i)]], ","))))), 3, 3, byrow=TRUE)
)
matrix(c(as.numeric((sapply(1:3, function(i)
unlist(strsplit(test[[paste0("v",i)]], ",")))))), 3, 3, byrow=TRUE)
runApp('shiny')
runApp('shiny')
