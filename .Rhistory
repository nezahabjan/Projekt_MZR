runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(inc_matrika)[1]]
network <- graph_from_adjacency_matrix(data)
#plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
#plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
#plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
#plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
m <- matrix(runif(12), 6, 2,
dimnames = list(NULL, c("x", "y")))
ui_1 <- fluidPage(   titlePanel("shinyMatrix: Simple App"),
sidebarPanel(     width = 6,     tags$h4("Data"),
matrixInput(       "sample",
value = m,
rows = list(
extend = TRUE       ),
cols = list(         names = TRUE       )     )   ),
mainPanel(     width = 6,     plotOutput("scatter")   ) )
server_1 <- function(input, output, session) {
output$scatter <- renderPlot({
plot(input$sample, col = "red", main = "Scatterplot")   }) }
shinyApp(ui_1, server_1)
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
m
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(inc_matrika)[1]]
network <- graph_from_adjacency_matrix(data)
#plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
#plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
#plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
#plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
#plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
#plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
#plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
#plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
#plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
#plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
#plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
#plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
#plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
#plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
#plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
#plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
runApp('shiny')
matrika
rm(matrika)
runApp('shiny')
m
rm(m)
runApp('shiny')
setwd("C:/Users/Neža/Desktop/Neža šola/opb projekt/Projekt_MZR")
shiny::runApp('shiny')
runApp('shiny')
runApp('shiny')
library(igraph)
library(ggraph)
library(networkD3)
library(shiny)
runApp('shiny')
install.packages("shinyglide")
library(shinyglide)
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp()
runApp('shiny')
runApp('shiny')
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
narisi <- function(matrika, directed, st_ogl, st_vrst, st_stolp){
# matrika je lahko vstavljena ali ne
# directed je lahko "yes" ali "no"
#st_ogl pride v postev le, ko je matrika prazna in zelimo usmerjen graf
#st_stolp in st_vrst prideta v postev le, ko je matrika prazna in zelimo neusmerjen graf
if (directed == "yes"){
# usmerjen graf se pravilno izrise, zanj potrebujemo kvadratno matriko s ?tevili povezav, vrstice in stolpci so enako poimenovani, vsaka povezava gre iz vrstic v stolpce
if (matrika !=""){
#ce je argument matrika izpolnjen ga upostevamo in uporabimo vstavljen graf uporabnika
#ta je OK
data <- matrika
rownames(data) = colnames(data) = letters[1:dim(matrika)[1]]
network <- graph_from_adjacency_matrix(data)
plot(network)
} else {
#sicer si program sam izbere nakljucno matriko izbranih dimenzij in izrise njej ustrezen graf
#ta je OK
data <- matrix(sample(0:1, st_ogl*st_ogl, replace=TRUE), st_ogl, st_ogl)
colnames(data) = rownames(data) = letters[1:st_ogl]
network <- graph_from_adjacency_matrix(data)
plot(network)
}
} else if (directed == "no"){
# pri neusmerjenih grafih imamo matriko, ki ni nujno kvadratna, v njej je 1 ?e povezava med tockama obstaja in 0 sicer
if (matrika !=""){
# ta je OK
data <- matrika
colnames(data) <- letters[1:dim(data)[2]]
rownames(data) <- LETTERS[(dim(data)[2] + 1):(dim(data)[1]+dim(data)[2])]
network <- graph_from_incidence_matrix(data)
plot(network)
} else {
# ta je OK
data <- matrix(sample(0:1, st_vrst*st_stolp, repl=TRUE), st_vrst, st_stolp)
colnames(data) <- letters[1:st_stolp]
rownames(data) <- LETTERS[(st_stolp + 1):(st_stolp + st_vrst)]
network <- graph_from_incidence_matrix(data)
plot(network)
}
}
return (list("network"=network, "directed"=directed, "matrika"=data))
}
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
runApp('shiny')
