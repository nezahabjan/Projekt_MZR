# C) koliko povezav vsebuje?
graf <- narisi(inc_matrika, "yes", 4, 5, 2)
povezave <- function(graf) {
matrika <- graf$matrika
stevilo_povezav <- sum(matrika)
return(stevilo_povezav)
}
# D) ali ima nas graf cikle?
graf <- narisi("", "no", 4, 4, 3)
cikli <- function(graf){
matrika <- graf$matrika
network <- graf$network
obiskani<- list()
seznam_stopenj <- stopnje(graf)
k <- 1
vozlisce <- names(network[1])[k]
while (seznam_stopenj[[vozlisce]] == 0){
obiskani[vozlisce] <- "DA"
k = k+1
vozlisce <- names(network[1])[k]
}
zacetni <- names(network[1])[k]
print(zacetni)
obiskani[zacetni] <- "DA"
# dobili smo prvega kandidata med vozlisci, kjer zacnemo preverjati ciklicnost
stars <- zacetni
otroci <- list()
cikel <- c()
while (length(obiskani)<length(names(network[1]))){
print(stars)
sosedje <- names(network[[stars]][[1]])
otroci[stars] <- sosedje
print(sosedje)
for (x in sosedje){
print(x)
if (obiskani[x]=="DA" && !(x %in% otroci[stars])){
print("imamo cikel")
print(cikel)
cikel <- c()
} else if (!(x %in% names(obiskani[]))){
print("Nadaljujmo")
cikel <- append(cikel, x)
print(cikel)
stars <- x
obiskani[x] <- "DA"
}
}
}
return(cikel)
}
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
Cikli
}
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
V(network[1])
V(network)
length(V(network)
length(V(network))
length(V(network))
x<-2
V(network)[x]
degree(network)
degree(network[x])
network[x]
network[[vozlisce]][[1]]
vozlisce <- V(network)[x]
network[[vozlisce]][[1]]
network
E(network)
network[[vozlisce]]
degree(network[[vozlisce]])
V(network)[x]
vozlisce <- V(network)[x]
stopnja <- length(network[[vozlisce]][[1]])
length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
seznam
V(network)[x][1]
V(network[1])[x]
network[1]
V(network)[1][x]
V(network)[1]
V(network)[[x]]
matrika
V(network)
V(network)[x]
names(network)
names(network[[1]])
names(network[[x]])
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
seznam
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
return(seznam)
}
# C) koliko povezav vsebuje?
graf <- narisi(inc_matrika, "yes", 4, 5, 2)
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
return(seznam)
}
stopnje(graf)
E(graf)
E(graf$network)
sum(E(graf$network))
length(E(graf$network))
povezave <- function(graf) {
stevilo_povezav <- length(E(graf$network))
return(stevilo_povezav)
}
povezave <- function(graf) {
stevilo_povezav <- length(E(graf$network))
return(stevilo_povezav)
}
# C) koliko povezav vsebuje?
graf <- narisi(inc_matrika, "yes", 4, 5, 2)
povezave(graf)
# D) ali ima nas graf cikle?
graf <- narisi("", "no", 4, 4, 3)
povezave(graf)
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
Cikli
}
najdi_cikle(graf)
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (Cikli == list()){
print("Graf nima ciklov!")
} else {
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
}
}
najdi_cikle(graf)
najdi_cikle = function(graf) {
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (Cikli == NULL){
print("Graf nima ciklov!")
} else {
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
}
}
}
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (Cikli == NULL){
print("Graf nima ciklov!")
} else {
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
}
}
najdi_cikle(graf)
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (Cikli){
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
} else {
print("Graf nima ciklov!")
}
}
najdi_cikle(graf)
length(Cikli)
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (length(Cikli)!=0){
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
} else {
print("Graf nima ciklov!")
}
}
length(Cikli)
najdi_cikle(graf)
# C) koliko povezav vsebuje?
graf <- narisi(inc_matrika, "yes", 4, 5, 2)
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (length(Cikli)!=0){
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
} else {
print("Graf nima ciklov!")
}
}
najdi_cikle(graf)
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
return(seznam)
}
# B) koliksne so stopnje oglisc?
graf <- narisi("", "yes", 4, 5, 2)
najdi_cikle(graf)
# funkcija dela v redu ampak potrebno je izločiti iz rezultata cikle, ki se ponovijo le v drugem vrstnem redu!
najdi_cikle = function(graf) {
Cikli = NULL
for(v1 in V(graf$network)) {
#gremo po vseh vozliscih grafa in najprej preverimo ali imajo stopnjo >0
if(degree(graf$network, v1, mode="in") == 0) { next }
#tedaj zberemo vse sosede tega vozlisca
dobri_sosedje = neighbors(graf$network, v1, mode="out")
dobri_sosedje = dobri_sosedje[dobri_sosedje > v1]
for(v2 in dobri_sosedje) {
#v vsakem vozliscu med dobrimi sosedi pogledamo enostavne povezave med v1 in v2
kandidat = lapply(all_simple_paths(graf$network, v2,v1, mode="out"), function(p) c(v1,p))
#obdrzimo pa samo tiste, ki imajo dolzino vecjo kot 3
kandidat = kandidat[which(sapply(kandidat, length) > 3)]
kandidat = kandidat[sapply(kandidat, min) == sapply(kandidat, `[`, 1)]
Cikli <- c(Cikli, kandidat)
}
}
if (length(Cikli)!=0){
print("Tu so vsi cikli v tem grafu!")
return(Cikli)
} else {
print("Graf nima ciklov!")
}
}
stopnje <- function(graf){
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
stopnja_grafa <- max(seznam)
return(list("seznam_stopenj"=seznam, "stopnja_grafa"=stopnja_grafa))
}
}
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
stopnja_grafa <- max(seznam)
return(list("seznam_stopenj"=seznam, "stopnja_grafa"=stopnja_grafa))
}
stopnje(graf)
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
stopnja_grafa <- max(seznam)
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
stopnja_grafa <- 0
}
}
return(list("seznam_stopenj"=seznam, "stopnja_grafa"=stopnja_grafa))
}
stopnje(graf)
stopnje <- function(graf){
seznam <- list()
network <- graf$network
directed <- graf$directed
matrika <- graf$matrika
if (directed == "no"){
# v primeru, da imamo opravka z neusmerjenim grafom je vsaka povezava do vozlisca ena stopnja vec
for (x in 1:length(V(network))){
vozlisce <- names(network[[x]])
stopnja <- length(network[[vozlisce]][[1]])
seznam[vozlisce] <- stopnja
}
} else if (directed =="yes"){
# v primeru, ko je nas graf usmerjen, delimo stopnje na vhodne in izhodne
#matrika_grafa <- get.adjacency(graf)
for (element in rownames(matrika)){
izhodna <- sum(matrika[element,])
vhodna <- sum(matrika[,element])
seznam[element] <- list(c("vhodna" = vhodna, "izhodna" = izhodna))
}
}
return(seznam)
}
stopnje(graf)
